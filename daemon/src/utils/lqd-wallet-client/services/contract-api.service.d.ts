import { ProofOfStake } from "../models/primitives/proof-of-stake.model";
import { Web3ServiceInterface } from "../interfaces/web3-service.interface";
import { Round } from "../models/wallet/round.model";
import { Signature } from "../models/primitives/signature.model";
import BigNumber from 'bignumber.js';
import { Aggregate } from "../models/transactions/aggregate.model";
import { AggregateDataInterface, TransferDataInterface, TransferWalletDataInterface } from "../interfaces/data.interface";
import { Transfer } from "../models/transactions/transfer.model";
export declare class ContractApiService {
    private web3;
    private contracts;
    constructor(web3: Web3ServiceInterface);
    private static promiseExecutor(resolve, reject);
    private static bigNumberValueOfResult(result);
    private static intValueOfResult(result);
    private static valueOfResult(result, idx?);
    private static indexedValueOfResult(idx);
    getABI(contractAddress: string, abi?: ({
        "constant": boolean;
        "inputs": {
            "name": string;
            "type": string;
        }[];
        "name": string;
        "outputs": {
            "name": string;
            "type": string;
        }[];
        "payable": boolean;
        "stateMutability": string;
        "type": string;
        anonymous?: undefined;
    } | {
        "inputs": {
            "name": string;
            "type": string;
        }[];
        "payable": boolean;
        "stateMutability": string;
        "type": string;
        constant?: undefined;
        name?: undefined;
        outputs?: undefined;
        anonymous?: undefined;
    } | {
        "payable": boolean;
        "stateMutability": string;
        "type": string;
        constant?: undefined;
        inputs?: undefined;
        name?: undefined;
        outputs?: undefined;
        anonymous?: undefined;
    } | {
        "anonymous": boolean;
        "inputs": {
            "indexed": boolean;
            "name": string;
            "type": string;
        }[];
        "name": string;
        "type": string;
        constant?: undefined;
        outputs?: undefined;
        payable?: undefined;
        stateMutability?: undefined;
    })[]): any;
    readonly available: boolean;
    networkId(): Promise<number>;
    latestBlock(): Promise<any>;
    latestBlockWithTransactions(): Promise<any>;
    genesis(contractAddress: string): Promise<number>;
    getLiveChallenges(roundNumber: number, contractAddress: string): Promise<number>;
    currentRound(contractAddress: string): Promise<number>;
    nextBlockRound(contractAddress: string): Promise<number>;
    currentSubBlock(contractAddress: string): Promise<number>;
    nextBlockSubBlock(contractAddress: string): Promise<number>;
    lastSubmissionRound(contractAddress: string): Promise<number>;
    balance(walletAddress: string, tokenAddress?: string): Promise<BigNumber>;
    allowance(tokenAddress: string, walletAddress: string, contractAddress: string): Promise<BigNumber>;
    pendingWithdrawals(tokenAddress: string, round: any, roundsKept: any, contractAddress: string): Promise<BigNumber>;
    getBlocksPerRound(contractAddress: string): Promise<any>;
    getSlackPeriod(contractAddress: string): Promise<any>;
    getExtendedSlackPeriod(contractAddress: string): Promise<any>;
    getRoundsKept(contractAddress: string): Promise<any>;
    getDepositsKept(contractAddress: string): Promise<any>;
    getChallengeCost(contractAddress: string): Promise<any>;
    recordBook(tokenAddress: string, walletAddress: string, contractAddress: string): Promise<any>;
    checkpoint(round: number, contractAddress: string, roundsKept: number): Promise<any>;
    metamaskHashFix(rawHash: any): any;
    static lqdWrapper(messageDigest: any): any;
    vrs(sig: any): string;
    private signPersonalInternal(data, account);
    signPersonal(data: any, account: any): Promise<Signature>;
    private signRawInternal(data, account);
    signRaw(data: any, account: any): Promise<Signature>;
    readonly canSignPersonal: boolean;
    sign(account: any, data: any): Promise<Signature>;
    recoverSigningAddress(signature: Signature, contractAddress: string): Promise<string>;
    validateAggregateSignature(aggregate: Aggregate, signature: Signature, contractAddress: string): Promise<boolean>;
    validateDataAggregate(transferData: TransferDataInterface, aggregateData: AggregateDataInterface, aggregateWallet: TransferWalletDataInterface, attestingAddress: string, contractAddress: string, tokenAddress: string, startingBalance?: BigNumber): Promise<boolean>;
    validateTransferDebit(transferData: TransferDataInterface, attestingAddress: string, contractAddress: string, tokenAddress: string): Promise<boolean>;
    validateTransferCredit(transferData: TransferDataInterface, attestingAddress: string, contractAddress: string, tokenAddress: string): Promise<boolean>;
    validateDeliveryProof(transfer: Transfer, deliveryProof: TransferDataInterface, contractAddress: string, tokenAddress: string): Promise<boolean>;
    recoverPersonal(data: any, signature: Signature): Promise<boolean>;
    validateSignature(signature: Signature, contractAddress: string): Promise<boolean>;
    getHubOwnerAddress(contractAddress: string): Promise<string>;
    validateHubSignature(signature: Signature, contractAddress: string): Promise<boolean>;
    doNothingOnce(account: string, contractAddress: string): Promise<any>;
    doNothing(count: number, account: string, contractAddress: string): Promise<any>;
    getDeposits(walletAddress: string, roundNumber: number, depositsKept: number, tokenAddress: string, contractAddress: string): Promise<BigNumber>;
    getTotalDepositAtSlot(slot: number, tokenAddress: string, contractAddress: string): Promise<BigNumber>;
    getTotalDepositRoundAtSlot(slot: number, tokenAddress: string, contractAddress: string): Promise<any>;
    getPendingWithdrawalsAtSlot(slot: number, tokenAddress: string, contractAddress: string): Promise<BigNumber>;
    getPendingWithdrawalsRoundAtSlot(slot: number, tokenAddress: string, contractAddress: string): Promise<any>;
    getConfirmedWithdrawalsAtSlot(slot: number, tokenAddress: string, contractAddress: string): Promise<BigNumber>;
    getConfirmedWithdrawalsRoundAtSlot(slot: number, tokenAddress: string, contractAddress: string): Promise<any>;
    deposit(tokenAddress: string, amount: BigNumber, account: string, contractAddress: string): Promise<any>;
    enableERC20Deposits(tokenAddress: string, walletAddress: string, contractAddress: string): Promise<any>;
    requestWithdrawal(amount: BigNumber, account: string, proof: ProofOfStake, contractAddress: string, minGasCost: BigNumber): Promise<any>;
    confirmWithdrawal(tokenAddress: string, account: string, contractAddress: string): Promise<any>;
    hasOutstandingChallenges(contractAddress: string): Promise<boolean>;
    hasMissedCheckpointSubmission(contractAddress: string): Promise<boolean>;
    isPunished(contractAddress: string): Promise<boolean>;
    estimateChallengeInitialEmptyStateCost(tokenAddress: string, walletAddress: string, trailIdentifier: number, txSetRoot: string, spent: BigNumber, gained: BigNumber, hubSignature: Signature, contractAddress: string): Promise<number>;
    submitChallengeInitialEmptyState(tokenAddress: string, walletAddress: string, trailIdentifier: number, txSetRoot: string, spent: BigNumber, gained: BigNumber, hubSignature: Signature, responseReimbursement: BigNumber, contractAddress: string): Promise<any>;
    estimateChallengeInitialMerkleStateCost(walletAddress: string, proof: ProofOfStake, txSetRoot: string, spent: BigNumber, gained: BigNumber, hubSignature: Signature, contractAddress: string): Promise<number>;
    submitChallengeInitialMerkleState(walletAddress: string, proof: ProofOfStake, txSetRoot: string, spent: BigNumber, gained: BigNumber, hubSignature: Signature, responseReimbursement: BigNumber, contractAddress: string): Promise<any>;
    estimateDeliveryCommitmentCost(tokenAddress: string, walletAddress: string, senderAddress: string, recipientAddress: string, nonce: BigNumber, senderTrailIdentifier: number, transferMembershipTrail: number, recipientTrailIdentifier: number, chain: string[], txSetRoot: string, spent: BigNumber, gained: BigNumber, amount: BigNumber, hubSignature: Signature, contractAddress: string): Promise<any>;
    submitDeliveryCommitment(tokenAddress: string, walletAddress: string, senderAddress: string, recipientAddress: string, nonce: BigNumber, senderTrailIdentifier: number, transferMembershipTrail: number, recipientTrailIdentifier: number, chain: string[], txSetRoot: string, spent: BigNumber, gained: BigNumber, amount: BigNumber, hubSignature: Signature, responseReimbursement: BigNumber, contractAddress: string): Promise<any>;
    getChallengeBook(tokenAddress: string, walletAddress: string, targetAddress: string, contractAddress: string): Promise<any>;
    verifyProofOfTransferAggregationRaw(transferMembershipTrail: number, chain: string[], target: string, amount: BigNumber, recipientTrailIdentifier: number, nonce: BigNumber, root: string, contractAddress: string): Promise<boolean>;
    verifyProofOfSwapAggregationRaw(sourceToken: string, destinationToken: string, transferMembershipTrail: number, chain: string[], amount: BigNumber, amountSwapped: BigNumber, startingBalance: BigNumber, recipientTrailIdentifier: number, nonce: BigNumber, root: string, contractAddress: string): Promise<boolean>;
    verifyProofOfTransitionAgreement(tokenAddress: string, walletAddress: string, trailIdentifier: number, round: number, txRoot: string, spent: BigNumber, gained: BigNumber, signature: Signature, contractAddress: string): Promise<string>;
    verifyProof(roundData: Round, merkleProof: ProofOfStake): Promise<any>;
    verifyProofRaw(tokenAddress: any, walletAddress: any, paint: any, trail: any, round: any, allotmentChain: any, membershipChain: any, values: any, left: any, right: any, contractAddress: string): Promise<any>;
    getStateUpdateEvents(tokenAddress: string, walletAddress: string, contractAddress: string): Promise<any>;
    getStateUpdateEventAtRound(tokenAddress: string, walletAddress: string, roundNumber: number, contractAddress: string): Promise<any>;
    recoverOnlyOnChainFunds(tokenAddress: string, account: string, contractAddress: string): Promise<any>;
    getReclaimableOnChainFunds(tokenAddress: string, account: string, contractAddress: string): Promise<BigNumber>;
    recoverAllFunds(proof: ProofOfStake): Promise<any>;
    getAllReclaimableFunds(proof: ProofOfStake): Promise<BigNumber>;
    testrpcMineBlock(): Promise<any>;
}
